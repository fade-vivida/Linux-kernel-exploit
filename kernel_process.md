# Kernel Process #
linux kernel 源码版本为 2.6.39.4


首先回答一个问题：到底什么是进程，什么是线程？进程、线程的区别又是什么？

一篇很好的文章：[https://www.zhihu.com/question/25532384](https://www.zhihu.com/question/25532384)

**注：名词是对客观事物的指代，形容词是对客观事物的描述**

个人对进程、线程的理解。一句话，进程就是程序执行的一个**实例**，而线程则是进程的一个**执行流**。也就是说进程和线程都可以理解为对 CPU 运行时间段的一个划分。不同点在于，进程粒度较大，包含了程序运行的各类资源（即我们常说的上下文），内核对进程进行切换时需要保存当前进程的上下文，然后装载待运行进程的上下文，即进程上下文的切换。而线程则是对进程执行流进一步的细粒度的划分，线程可以共享进程的某些资源，从而在线程切换时不用对上下文内容也进行切换（注：这里所说的线程切换指同进程的线程，不同进程间的线程切换还是需要首先切换上下文信息）。


## 1. 进程链表 ##
### 1.1 init_task 变量 ###
进程链表是把所有进程描述符都链接起来的一个双向链表。每个 task\_struct 结构都包含一个 list\_head 类型的 task 字段，这个类型的 prev 和 next 字段分别指向前面和后面的 task\_struct 元素。

这里就有一个问题，既然是双向链表那么就应该有一个头结点。这个头结点就是 init\_task 描述符（init\_task 代表所谓的 0 号进程（process 0）或者也可以叫做 swapper 进程）。我们先来看看 kernel 是如何对 init\_task 进行初始化的。

	// init_task.c
	struct task_struct init_task = INIT_TASK(init_task);
	EXPORT_SYMBOL(init_task);
kernel 调用 INIT\_TASK宏对 init\_task 全局变量进行初始化。

	// init_task.h
	/*
	 *  INIT_TASK is used to set up the first task table, touch at
	 * your own risk!. Base=0, limit=0x1fffff (=2MB)
	 */
	#define INIT_TASK(tsk)	\
	{									\
		.state		= 0,						\
		.stack		= &init_thread_info,				\
		.usage		= ATOMIC_INIT(2),				\
		.flags		= PF_KTHREAD,					\
		.lock_depth	= -1,						\
		.prio		= MAX_PRIO-20,					\
		.static_prio	= MAX_PRIO-20,					\
		.normal_prio	= MAX_PRIO-20,					\
		.policy		= SCHED_NORMAL,					\
		.cpus_allowed	= CPU_MASK_ALL,					\
		.mm		= NULL,						\
		.active_mm	= &init_mm,					\
		.se		= {						\
			.group_node 	= LIST_HEAD_INIT(tsk.se.group_node),	\
		},								\
		.rt		= {						\
			.run_list	= LIST_HEAD_INIT(tsk.rt.run_list),	\
			.time_slice	= HZ, 					\
			.nr_cpus_allowed = NR_CPUS,				\
		},								\
		.tasks		= LIST_HEAD_INIT(tsk.tasks),			\
		INIT_PUSHABLE_TASKS(tsk)					\
		.ptraced	= LIST_HEAD_INIT(tsk.ptraced),			\
		.ptrace_entry	= LIST_HEAD_INIT(tsk.ptrace_entry),		\
		.real_parent	= &tsk,						\
		.parent		= &tsk,						\
		.children	= LIST_HEAD_INIT(tsk.children),			\
		.sibling	= LIST_HEAD_INIT(tsk.sibling),			\
		.group_leader	= &tsk,						\
		RCU_INIT_POINTER(.real_cred, &init_cred),			\
		RCU_INIT_POINTER(.cred, &init_cred),				\
		.comm		= "swapper",					\
		.thread		= INIT_THREAD,					\
		.fs		= &init_fs,					\
		.files		= &init_files,					\
		.signal		= &init_signals,				\
		.sighand	= &init_sighand,				\
		.nsproxy	= &init_nsproxy,				\
		.pending	= {						\
			.list = LIST_HEAD_INIT(tsk.pending.list),		\
			.signal = {{0}}},					\
		.blocked	= {{0}},					\
		.alloc_lock	= __SPIN_LOCK_UNLOCKED(tsk.alloc_lock),		\
		.journal_info	= NULL,						\
		.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
		.fs_excl	= ATOMIC_INIT(0),				\
		.pi_lock	= __RAW_SPIN_LOCK_UNLOCKED(tsk.pi_lock),	\
		.timer_slack_ns = 50000, /* 50 usec default slack */		\
		.pids = {							\
			[PIDTYPE_PID]  = INIT_PID_LINK(PIDTYPE_PID),		\
			[PIDTYPE_PGID] = INIT_PID_LINK(PIDTYPE_PGID),		\
			[PIDTYPE_SID]  = INIT_PID_LINK(PIDTYPE_SID),		\
		},								\
		.thread_group	= LIST_HEAD_INIT(tsk.thread_group),		\
		.dirties = INIT_PROP_LOCAL_SINGLE(dirties),			\
		INIT_IDS							\
		INIT_PERF_EVENTS(tsk)						\
		INIT_TRACE_IRQFLAGS						\
		INIT_LOCKDEP							\
		INIT_FTRACE_GRAPH						\
		INIT_TRACE_RECURSION						\
		INIT_TASK_RCU_PREEMPT(tsk)					\
	}
### 1.2 list\_head 相关操作 ###
#### 1.2.1 list\_entry ####
关于 list\_entry\_xxx 宏的理解。  
在 linux kernel 中，双向链表使用 list\_head 类型的结构体来将一个个对象链接起来。假设存在如下所示的结构体：  

	strcut my_struct{
		int a;
		int b;
		......
		list_head list_a
		......
	}
其中 list\_a->next 和 list\_a->prev 均指向了下一个 list\_head 结构体。这里就有一个问题，以上面的结构体为例，我们通过 list\_a 字段找到了下一个同类型元素（my\_struct）的 list\_a 字段，但我们想要的是包含该字段的结构体 my\_struct 的地址，我们怎样通过 list\_a 得到该地址呢？

对，答案很简单，减去偏移（即 addr\_my\_struct = addr\_list\_a - offset\_list\_a_)。这其实就是 list\_entry\_xxx（p,t,m） 宏所做的事情，该宏定义需要提供三个参数 p,t,m。其中 p 就为上面所说的某个 my\_struct 实例中 list\_a 的地址，t 为该对象的类型（即 my\_struct），m 为该字段的名称（即 list\_a），可以看出后两个参数就是用来计算偏移所用。

#### 1.2.2 list\_add ####
	// list.h
	static inline void list_add(struct list_head *new, struct list_head *head)
	{
		__list_add(new, head, head->next);
	}
	static inline void list_add_tail(struct list_head *new, struct list_head *head)
	{
		__list_add(new, head->prev, head);
	}
	static inline void __list_add(struct list_head *new,
				      struct list_head *prev,
				      struct list_head *next)
	{
		next->prev = new;
		new->next = next;
		new->prev = prev;
		prev->next = new;
	}
没什么好说的，双向链表的基本操作，list\_add 将 new 插入 head 之后，list\_add\_tail 将 new 插入 head 之前。
#### 1.2.3 list\_for\_each ####
	// list.h
	#define list_for_each(pos, head) \
		for (pos = (head)->next; prefetch(pos->next), pos != (head); \
	        	pos = pos->next)
	#define list_for_each_entry(pos, head, member)				\
		for (pos = list_entry((head)->next, typeof(*pos), member);	\
		     prefetch(pos->member.next), &pos->member != (head); 	\
		     pos = list_entry(pos->member.next, typeof(*pos), member))
可以看到，list\_for\_each 用来遍历表头 head 指向的链表，通过 pos 返回 list\_head 结构的指针。而 list\_for\_each\_entry 同样是对 head 指向的链表进行遍历，但 pos 返回的是包含该 member 成员的结构的指针。

对进程描述符进行遍历的宏定义如下所示：

	#define next_task(p) \
		list_entry_rcu((p)->tasks.next, struct task_struct, tasks)

	#define for_each_process(p) \
		for (p = &init_task ; (p = next_task(p)) != &init_task ; )
我们发现其实该宏定义与 list\_for\_each\_entry 基本相同。
#### 1.2.4 list\_del ####
	static inline void list_del(struct list_head *entry)
	{
		__list_del(entry->prev, entry->next);
		entry->next = LIST_POISON1;
		entry->prev = LIST_POISON2;
	}
	static inline void __list_del(struct list_head * prev, struct list_head * next)
	{
		next->prev = prev;
		prev->next = next;
	}
#### 1.2.5 list\_empty ####
	static inline int list_empty(const struct list_head *head)
	{
		return head->next == head;
	}

### 1.3 进程链表 ###
#### 1.3.1 tasks 字段 ####
tasks 字段用来将所有当前存在的进程链接在以 init\_task 为头的双向链表中。
#### 1.3.2 TASK\_RUNNING 状态的进程链表 ####
涉及字段包括：**run\_list，prio，array**  

虽然我们仅通过 tasks 字段所指向的双向链表也能找到所有当前正在运行的进程，但开销太大。因此，linux kernel 采用了一种新的调度方法。

每个 task\_struct 描述符包含一个 list\_head 类型的字段 run\_list。如果当前进程的优先级等于 k（prio字段，且 0<=k<=139），run\_list 字段就把该进程链入优先权级为 k 的可运行进程链表中。同时，每个 CPU 都有它自己的运行队列，即它自己的进程链表集，其结构为 rt\_prio\_array 结构体。

	#define MAX_RT_PRIO 140
	struct rt_prio_array {
		int nr_active；//当前源码中已无该字段
		DECLARE_BITMAP(bitmap, MAX_RT_PRIO+1); /* include 1 bit for delimiter */
		struct list_head queue[MAX_RT_PRIO];
	};
enqueue\_task（p，array）函数把进程描述符插入某个运行队列的链表中，其代码本质上等同于：  

	list_add_tail(&p->run_list,&array->queue[p->prio]);
	__set_bit(p->prio,array->bitmap);
	array->nr_active++;
	p->array = array;
进程描述符的 prio 字段存放进程的动态优先级，而 array 字段是一个指针，指向当前运行队列的 rt\_prio\_array 数据结构。类似地，dequeue\_task（p，array）函数从运行队列的链表中删除一个进程描述符。
#### 1.3.3 进程间的关系 ####
关于进程 0 和进程 1。进程 0 和进程 1 由内核创建，进程 1（init）为所有进程的祖先。描述符中与进程亲属关系相关的字段有： 
 
- **real\_parent**：指向创建了 P 的进程的描述符，如果 P 的父进程不再存在，则指向进程 1（init）的描述符  
- **parent**：指向 P 当前的父进程，它的值通常与 real\_parent 相同，但偶尔也可以不同，例如：当另一个进程发出监控 P 的 ptrace（）调用请求时
- **children**：链表头部，链表中元素都为 P 创建的子进程
- **sibling**：链表头部，指向兄弟进程链表中的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是 P

sched.h 中 task\_struct 结构体中关于上述 4 个字段的定义如下

	/* pointers to (original) parent process, youngest child, younger sibling,older sibling, respectively.  
		(p->father can be replaced with p->real_parent->pid) */
	struct task_struct *real_parent; /* real parent process */
	struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */
	
	// children/sibling forms the list of my natural children
	
	struct list_head children;	/* list of my children */
	struct list_head sibling;	/* linkage in my parent's children list */

还有一些其他的字段是关于进程间非亲属关系的，例如：

- **group\_leader**：P 所在进程组的领头进程描述符
- **signal -> leader\_pid**：P 所在的进程组领头进程的 PID
- **tgid**：P 所在的线程组的领头进程的 PID
- **ptraced**：链表头，指向 P 跟踪的所有进程。包括 P 本身的子进程，以及使用了 ptrace 的进程
- **ptrace\_entry**：指向 P 其父进程的 ptraced 链表（用户 P 被跟踪时）。

ptraced 与 ptrace\_entry 的区别在于，P->ptraced 字段是用来查找 P 所跟踪的所有子进程（即 P 为发起跟踪的进程）。而 P->ptrace\_entry 则是指向跟踪 P 的进程的 ptraced 字段（即 P 为被跟踪的进程）。

源代码如下所示：

	struct task_struct *group_leader;	/* threadgroup leader */
	
	pid_t tgid;

	/*ptraced is the list of tasks this task is using ptrace on.
	This includes both natural children and PTRACE_ATTACH targets.
	p->ptrace_entry is p's link on the p->parent->ptraced list.*/
	
	struct list_head ptraced;
	struct list_head ptrace_entry;
## 2. PID与进程描述符 ##
PID，进程标识符是我们平常所用的最多与进程相关的一个结构，例如：使用 kill（）系统调用时等。在进程描述符（task\_struct）中的 pid 字段就保存了当前进程的标识符 PID。
	
	struct task_struct{
		......
		pid_t pid;
		pid_t tgid;
		......
	}
那么就存在一个问题，内核是如何通过 PID 来找到其所对应的 task\_struct 结构体的呢？

通过 init\_task 全局变量进行遍历是一个可行的方案，但对于当前动则成千上完个进程的系统而言，顺序遍历是相当低效的。因此，为了加速查找，Linux kernel 引入了 4 个散列表。
### 2.1 pidhash表及链表 ###

	struct task_struct{
		......
		struct pid_link pids[PIDTYPE_MAX];
		......
	}
